Counter가 진짜 이상한 자료구조임.

일단 Counter의 생성자 인자로 iterable이랑 mapping(key-val) 둘다 들어갈 수 있음.

그리고 dict는 할 수 없는 +, -, &, |을 지원해줌.
set은 할 수 있는데 dict는 위에 전부 못하죠

그리고 저런 연산을 할때마다 value가 0이하인 애들은 전부 알아서 제거함.
`.update` 와 `.subtract` 도 마찬가지임.

+와 - 연산자를 쓰면 근데 성능 이슈가 있어서
하나씩 바꿀때는 직접 값을 수정해줘야하는데, 이때는 0이하로 떨어진다고해서 자동으로 삭제해주거나 그런거 없음.

---

dict도 특이하게 생성자로 다른dict.items()를 그대로 받아도 되고, 아니면 다른dict를 그대로 넣어도 됨.
그래서 Counter, dict, defaultdict 간에 형변환은 자유로움.
(단, defaultdict의 첫번쨰인자는 무조건 default팩토리임. 두번째 인자에다가 dict같은거 넣어주면 됨.)

어차피 Counter하고 defaultdict는 dict의 자식클래스들이고,
.get("key", 디폴트값) 으로 예외없이 디폴트값을 사용해줄 수 있음.

---

일단 모두 iterable이 아님. -> \*연산자 지원 X
iter로 감싸면? -> set은 잘 되는데, dict는 key만 나옴 -> 그래서 for문에다 바로 dict 넣으면 dict.keys()와 동일.

[], in, not in, ==, !=은 공통이고,

Counter: +, -, &, | 지원 (단, 연산하면 value가 0이하인 아이템들 다 삭제됨.)
set: |, &, ^, <, <=, >, >= 지원 (애초에 +는 필요가 없으니깐) (부분집합도 계산해줄줄은 몰랐음.)
dict, defaultdict: 위에 아무것도 지원안함. 직접 만들어 써야함.

---

암튼 dict에서 연산을 구현하려면

1. 일단 `{*딕셔너리.keys()}`로 키 셋을 얻어낸뒤, 연산을 해서 원하는 키 집합을 만들어내고
2. `for key in 연산한키` 와 `딕셔너리.get(key, 디폴트값)` 으로 value 연산을 해주면 됨.

이 두개만 하면 솔직히 문제 없음.

---
