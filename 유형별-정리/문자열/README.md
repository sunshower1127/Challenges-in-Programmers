# 정규식 사용법 정리

문자 하나
`. : 임의의 단일 문자와 매치 (줄바꿈 제외)`
`\w : 알파벳, 숫자, 밑줄(_) 매치`
`\W : \w가 아닌 모든 문자 매치`
`\d : 숫자(0-9) 매치`
`\D : 숫자가 아닌 모든 문자 매치`
`\s : 공백(스페이스, 탭 등) 매치`
`\S : 공백이 아닌 모든 문자 매치`
`[문자들] : 대괄호 안 문자 중 하나와 매치`
`[^문자들] : 대괄호 안에 없는 문자와 매치`
`[문자들^문자들]`
`(내용|내용) : 여러 패턴 중 하나 매치`

---

`^ : 문자열의 시작 위치 매치`
`$ : 문자열의 끝 위치 매치`
`\b : 단어 경계(Boundary)`
`\B : 단어 경계가 아닌 위치`

---

`문자? : 바로 앞 문자가 0회 또는 1회 등장`
`문자* : 바로 앞 문자가 0회 이상 등장`
`문자+ : 바로 앞 문자가 1회 이상 등장`
`문자+? : 최소로 매치하는 탐욕 방지 문법`
`{최소,최대} : 횟수 범위 지정`

---

`\숫자 : 이전에 캡처한 그룹 참조(1부터)`
`(?:내용) : 캡처 없이 그룹 처리`

---

`(?=내용) : 뒤쪽이 특정 내용과 이어지는지 확인`
`(?<=내용) : 앞쪽이 특정 내용과 이어지는지 확인`
`(?!내용) : 뒤쪽이 특정 내용과 이어지지 않는지 확인`
`(?<!내용) : 앞쪽이 특정 내용과 이어지지 않는지 확인`
(findall 쓸때는 필요없음)
이게 유용한건 캡쳐는 하는데 실질적으로 진행은 안되게 할 수 있음.
예를들어 2글자씩 캡쳐하고 싶은데, 이걸 겹쳐서 캡쳐하고 싶단 말임.
예) "abc" -> "ab", "bc" 이렇게.
캡쳐로직은 빈 전방탐색에 넣고, 진행 로직은 따로 뒤에 넣으면 됨.
예) r"(?=([a-z]{2}))[a-z]"
진짜 고급 로직이다 이거죠 겹쳐서 탐색하기

---

심화

`.*` : 와일드 카드. 모든 문자열 집합
`\((.*?)\)` : 괄호 안에 문자열 캡처 (findall 쓸때는 필요없음)
`[a-zA-Z]+` : 영어 단어

sub에서 어떻게 바꿀지 인자로 문자열을 그냥 줄 수도 있고,
함수로 받으면, m.group(n)으로 캡쳐한거 접근할 수 있음.

python 사용법

```python
import re

p = re.compile(r"정규식")

# 1개만 찾기
match = p.search("input_string")

# 여러개 찾기
string_list = p.findall("input_string")
# findall 안에다가 group을 하나 만들면 match대신 group을 리턴해줌.

# match로 받기(캡쳐용)
match_iter = p.finditer("input_string")

# 바꾸기
new_string = p.sub("어떻게바꿀지", "input_string")

# 쪼개기

split_parts = p.split("input_string")

```

그러니깐 여러개를 찾을 일이 있을때
그냥 부분 정규식만 쓸거면 -> findall

모든 부분의 정규식을 다 쓰고 캡쳐한거 여러개 받을거다 -> match
이렇게 인듯.

findall, finditer, split, sub -> 찾는 부분의 정규식만 씀
search -> 전체 부분의 정규식을 써야함.

위에는 정규식 탐색이 끝나도, 끝날때까지 반복되고,
아래는 정규식 탐색이 끝나면 끝남. 즉 시작부분, 끝부분 신경을 써줘야함.
